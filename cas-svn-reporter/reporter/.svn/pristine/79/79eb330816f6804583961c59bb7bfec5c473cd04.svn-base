from test_failure import TestFailure


def strip_config_from_url(url):
    # The substring "label=<os-target>.<config-name>" is always present in the
    # config url so by finding the = sign, we can gather the config name
    # characters until we reach a / character.
    config_pos = url.find("=")

    if config_pos == -1:
        return "Unknown Configuration"

    # Increment position past equals sign
    config_pos += 1

    # Initialise config string we are building to the empty string
    config_string = ""

    while url[config_pos] != "/":
        config_string += url[config_pos]
        config_pos += 1

    os_target, branch_name = config_string.split('.', 1)
    node = config_string

    return (node, branch_name, os_target)


class JobTestResultParser:
    """
    JobTestResultParser(job_test_results)

    Class to parse job test results in json format received from a Jenkins 
    master instance. Provides methods for scanning test results for failures, 
    and collating results into POD objects for later processing.

    job_test_results: list - A list containing dictionary structures mirroring 
                             test result json files retrieved for each job from
                             the Jenkins server
    """

    def __init__(self, job_test_results):
        self.job_test_results = job_test_results

    def collate_test_failures(self) -> list:

        # Gather the failures for each job
        job_set_failures = [
            self.scan_job_for_failures(job)
            for job in self.job_test_results
        ]

        # Merge bitisms into one list for each job
        for i, next_i in zip(job_set_failures, job_set_failures[1:]):
            # If i or next_i is empty or None, skip to the next comparison.
            if not i or not next_i:
                continue

            # If branches match in different jobs, they are different bitisms
            # and should be in the same data set.
            if i[0].branch == next_i[0].branch:
                job_set_failures.append(i + next_i)
                job_set_failures.remove(i)
                job_set_failures.remove(next_i)

        return job_set_failures

    def scan_job_for_failures(self, job) -> list:
        if job is None:
            return []

        job_configurations = job['childReports']

        # Only investigate configurations that had failing tests
        config_failures = [
            self.scan_configuration_for_failures(config, job)
            for config in job_configurations
            if config['result']['failCount'] != 0
        ]

        # Flatten results from each configuration into one list for the whole
        # job
        job_failures = [
            test_failure
            for config in config_failures
            for test_failure in config
        ]

        return job_failures

    def scan_configuration_for_failures(self, config, job) -> list:
        # Identify configuration name so we can tag any failures with the
        # name for future reference
        config_string = strip_config_from_url(config['child']['url'])

        failed_tests = []

        for suite in config['result']['suites']:
            for case in suite['cases']:

                if case['status'] == "FAILED" or \
                   case['status'] == "REGRESSION":

                    test_failure = TestFailure(
                        config_string[0],
                        config_string[1],
                        case['className'],
                        case['name'],
                        config_string[2],
                        case['age'],
                        job['jobName'],
                        job['jobNumber']
                    )

                    failed_tests.append(test_failure)

        return failed_tests
